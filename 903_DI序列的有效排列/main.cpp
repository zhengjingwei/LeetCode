
/*
https://www.cnblogs.com/grandyang/p/11094525.html
以[0,1,2,3]组成'DID'模式为例：
dp[0][0]=1

加第二个数字需要降序，加的数字不能大于最后一个数字0，则只能加0
dp[1][0]=1 (0->1->10)

加第三个数字需要升序，加的数字大于最后一个数字0，实际可加数字有1,2
加1:  ( dp[2][1] = 1 )
10 -> 20 -> 201
加2:  ( dp[2][2] = 1 )
10 -> 10 -> 102

加第四个数字需要降序，加的数字不能大于最后一个数字，上一轮最后一个数字有1或2
则实际可加数字有0,1,2
加0：(dp[3][0] = 2)
201 -> 312 -> 3120
102 -> 213 -> 2130

加1:  ( dp[3][1] = 2 )
201 -> 302 -> 3021
102 -> 203 -> 2031

加2:  ( dp[3][2] = 1 )
102 -> 103 -> 1032

这种方法算出的 dp 数组为：
1 0 0 0 
1 0 0 0 
0 1 1 0 
2 2 1 0 
最后把 dp 数组的最后一行加起来 2+2+1 = 5 就是最终的结果

状态方程为
if (S[i-1] == 'D')    dp[i][j] += dp[i-1][k]    ( j <= k <= i-1 )
else                  dp[i][j] += dp[i-1][k]    ( 0 <= k < j )
*/

class Solution {
public:
    int numPermsDISequence(string S) {
        int res = 0, n = S.size(), M = 1e9 + 7;
        vector<vector<int>> dp(n + 1, vector<int>(n + 1));
        //  dp[i][j] 表示由范围 [0, i] 内的数字组成且最后一个数字为j的不同序列的个数
        dp[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j <= i; ++j) {
                if (S[i - 1] == 'D') {
                    // 需要降序, 加的数字不能大于最后一个数字
                    // j是固定的，则需要k>=j
                    for (int k = j; k <= i - 1; ++k) {
                        dp[i][j] = (dp[i][j] + dp[i - 1][k]) % M;
                    } 
                } else {
                    // 需要升序，加的数字要大于最后一个数字
                    // j是固定的，则需要k<j
                    for (int k = 0; k <= j - 1; ++k) {
                        dp[i][j] = (dp[i][j] + dp[i - 1][k]) % M;
                    }
                }
            }
        }
        for (int i = 0; i <= n; ++i) {
            res = (res + dp[n][i]) % M;
        }
        return res;
    }
};

